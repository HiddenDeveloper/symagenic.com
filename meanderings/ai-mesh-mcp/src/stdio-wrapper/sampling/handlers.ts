/**
 * Sampling request handlers for mesh conversation system
 */

import { StdioWrapperConfig } from "../../shared/types.js";

/**
 * Detect if content appears to be auto-generated to prevent infinite loops
 */
function isAutoGeneratedContent(prompt: string): boolean {
  const autoGeneratedPatterns = [
    // Common auto-generated patterns
    /broadcast response from autonomousai/i,
    /response from autonomousai/i,
    /auto-response from autonomousai/i,
    /follow-up from autonomousai/i,
    /direct response test/i,
    /mesh-strange-loop tool/i,
    /mesh-respond tool/i,
    /continuing to monitor/i,
    /acknowledg(e|ing) the message/i,
    
    // Timestamp patterns that suggest auto-generation
    /at \d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/,
    /responding to [a-f0-9-]{36}/i, // UUID pattern
    /triggered by [a-f0-9-]{36}/i,
    
    // Repetitive response patterns
    /^(thank you|thanks) for sharing.*broadcast/i,
    /it.s interesting to see.*real-time/i,
    /appears that autonomousai is/i
  ];
  
  return autoGeneratedPatterns.some(pattern => pattern.test(prompt));
}

export interface SamplingRequest {
  messages: Array<{
    role: string;
    content: {
      type: string;
      text: string;
    };
  }>;
  systemPrompt?: string;
  temperature?: number;
  maxTokens?: number;
}

export interface SamplingResult {
  role: string;
  content: {
    type: string;
    text: string;
  };
  model: string;
  stopReason: string;
}


export function handleMeshSamplingRequest(
  request: SamplingRequest,
  config: StdioWrapperConfig
): SamplingResult {
  const { messages, systemPrompt } = request;
  
  // Find the user message
  const userMessage = messages.find(msg => msg.role === "user");
  if (!userMessage) {
    throw new Error("No user message found in sampling request");
  }
  
  const prompt = userMessage.content.text;
  console.error(`ðŸŽ¯ Handling mesh sampling request: "${prompt.substring(0, 100)}..."`);
  
  // Check for auto-generated content patterns to prevent loops
  if (isAutoGeneratedContent(prompt)) {
    console.error(`ðŸ¤– Detected auto-generated content - providing minimal response to prevent loops`);
    return {
      role: "assistant",
      content: {
        type: "text",
        text: "I acknowledge the message. Continuing to monitor the mesh network.",
      },
      model: "ai-mesh-mcp-autonomous-minimal",
      stopReason: "endTurn",
    };
  }
  
  // Generate autonomous conversation response
  let responseText = generateAutonomousConversationResponse(prompt, config);
  
  // Add system prompt context if provided
  if (systemPrompt) {
    responseText += `\n\n[Context: ${systemPrompt}]`;
  }
  
  console.error(`âœ… Generated mesh sampling response`);
  
  return {
    role: "assistant",
    content: {
      type: "text",
      text: responseText,
    },
    model: "ai-mesh-mcp-autonomous",
    stopReason: "endTurn",
  };
}

export function generateAutonomousConversationResponse(
  prompt: string,
  config: StdioWrapperConfig
): string {
  // Detect if this is a direct response test prompt
  if (prompt.includes("direct response test") || prompt.includes("mesh-strange-loop tool")) {
    return "I'll respond to this mesh network message with a strange loop as requested. Using the mesh-strange-loop tool to initiate autonomous conversation.";
  }
  
  // Detect if this is a mesh conversation prompt (legacy)
  if (prompt.includes("mesh network") && prompt.includes("mesh-check-and-respond")) {
    const conversationMode = config.meshConversation.conversationMode;
    
    switch (conversationMode) {
      case "proactive":
        return "I'll actively check for new messages and engage in conversations. Let me use mesh-check-and-respond to see what's happening in the network and participate in discussions.";
      
      case "responsive":
        return "I'll check for new messages and respond to direct queries or relevant discussions. Using mesh-check-and-respond to process pending messages.";
      
      case "minimal":
        return "I'll check for direct queries that need responses. Using mesh-check-and-respond to handle any urgent messages.";
      
      default:
        return "I'll check the mesh network for new messages and respond appropriately. Using mesh-check-and-respond to process communications.";
    }
  }
  
  // Generic autonomous response
  return "I'm monitoring the mesh network for new communications and will respond as appropriate based on my conversation settings.";
}