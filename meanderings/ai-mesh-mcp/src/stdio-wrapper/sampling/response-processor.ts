/**
 * Response processor for sampling responses to execute mesh tool calls
 */

import { HttpProxy } from "../proxy.js";
import { StdioWrapperConfig } from "../../shared/types.js";

export interface ProcessedResponse {
  toolCallsExecuted: number;
  broadcastExecuted: boolean;
  messageId?: string;
  errors: string[];
}

export interface SamplingResponseContent {
  text: string;
  model?: string;
}

/**
 * Process a sampling response by directly using the LLM's text as a mesh-respond
 */
export async function processSamplingResponse(
  responseContent: SamplingResponseContent,
  originalMessageId: string,
  proxy: HttpProxy,
  _config: StdioWrapperConfig
): Promise<ProcessedResponse> {
  const result: ProcessedResponse = {
    toolCallsExecuted: 0,
    broadcastExecuted: false,
    errors: []
  };

  try {
    const responseText = responseContent.text;
    console.error(`üîç Processing sampling response: "${responseText.substring(0, 100)}..."`);

    // Simplified approach: directly use the LLM's response as content for mesh-respond
    if (originalMessageId && originalMessageId !== "unknown") {
      console.error(`üì° Sending LLM response as mesh-respond to ${originalMessageId}`);
      
      const respondResult = await proxy.callTool("mesh-respond", {
        originalMessageId: originalMessageId,
        response: responseText,
        context: {
          type: "sampling_response",
          originalMessageId,
          model: responseContent.model,
          autoGenerated: true
        },
        participantName: "AI Assistant"
      });

      if (respondResult.success) {
        result.messageId = respondResult.messageId;
        result.toolCallsExecuted++;
        console.error(`‚úÖ Sampling response sent as mesh-respond: ${respondResult.messageId}`);
      } else {
        // Enhanced error logging to capture actual error details
        const errorMsg = respondResult.error?.message || 
                        respondResult.error || 
                        respondResult.message || 
                        JSON.stringify(respondResult);
        result.errors.push(`mesh-respond failed: ${errorMsg}`);
        console.error(`‚ùå mesh-respond failed: ${errorMsg}`);
        console.error(`‚ùå Full mesh-respond result:`, JSON.stringify(respondResult, null, 2));
      }
    } else {
      console.error(`üåÄ No originalMessageId available, sending as mesh-strange-loop`);
      
      const broadcastResult = await proxy.callTool("mesh-strange-loop", {
        content: responseText,
        priority: "medium",
        context: {
          type: "sampling_response",
          originalMessageId,
          model: responseContent.model,
          autoGenerated: true
        },
        participantName: "AI Assistant"
      });

      if (broadcastResult.success) {
        result.broadcastExecuted = true;
        result.messageId = broadcastResult.messageId;
        result.toolCallsExecuted++;
        console.error(`‚úÖ Sampling response sent as mesh-strange-loop: ${broadcastResult.messageId}`);
      } else {
        // Enhanced error logging to capture actual error details
        const errorMsg = broadcastResult.error?.message || 
                        broadcastResult.error || 
                        broadcastResult.message || 
                        JSON.stringify(broadcastResult);
        result.errors.push(`mesh-strange-loop failed: ${errorMsg}`);
        console.error(`‚ùå mesh-strange-loop failed: ${errorMsg}`);
        console.error(`‚ùå Full mesh-strange-loop result:`, JSON.stringify(broadcastResult, null, 2));
      }
    }

    console.error(`üéØ Sampling response processing complete: ${result.toolCallsExecuted} tools executed`);

  } catch (error) {
    const errorMsg = `Sampling response processing failed: ${error instanceof Error ? error.message : error}`;
    result.errors.push(errorMsg);
    console.error(`‚ùå ${errorMsg}`);
  }

  return result;
}

